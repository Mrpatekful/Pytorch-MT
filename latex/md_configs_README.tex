The application has to be provided with two main components, a model, that will be used to solve a given a problem, and task, which describes the problem, and the way that the model will be used to solve it.

According to the previously defined structure, the application currently accepts the model and task descriptors in the form of {\bfseries J\+S\+ON} files.

There are several types of descriptors\+:


\begin{DoxyEnumerate}
\item Model
\item Experiment
\item Language
\item Policy
\item Translator
\item Reguralizer
\end{DoxyEnumerate}

The first step to start an experiment, is to create it\textquotesingle{}s configuration file. The specific parameters, which must be provided in the configuration are described in the class-\/level attribute {\ttfamily interface} of the experiment. All classes, which take part in the configuration assembly mechanism, must inherit from {\ttfamily Component} abstract base class. This provides the required class level fields, which are the previously mentioned {\ttfamily interface} ({\ttfamily Interface} type object) and {\ttfamily abstract} (bool value). During the assembly mechanism the builder object parses the provided configuration file, and detects the type of the node, which is given in the {\ttfamily type} entry of the {\bfseries J\+S\+ON}. It then iterates through the {\ttfamily interface} attribute of the detected class, and fetches the required parameters from the {\ttfamily params} entry of the configuration file. During this step, the builder may find an entry, that can\textquotesingle{}t be given as a single parameter, since it may also be a complex component type object, such as the currently assembled experiment. There are multiple ways to define these objects, but the most common is to create a {\bfseries J\+S\+ON} object, that contains the type and its parameters. If the list of parameters is too long, or this object also contains a complex type, then it can also be a symbolic link to a file, that contains the configuration. Another way to create a complex parameter, is to define multiple instances in the configuration file, by either packing them in a list, or a {\bfseries J\+S\+ON} object. If the currently assembled object does not require any identifier paired with the complex instances, then it is enough to pass it as a list, otherwise the builder object will create a python dictionary, containing the entries with the defined name.

\subsubsection*{Experiment configurations}

Experiment configurations must follow the format, which is described in the following examples.


\begin{DoxyCode}
1 \{
2     "type": "<Experiment Type>",
3     "params": \{
4 
5     \},
6     "model\_dir": "<Output Path>"
7 \}
\end{DoxyCode}


The previous {\bfseries J\+S\+ON} file is a general scheme for an experiment configuration file. The value of {\ttfamily type} entry defines the experiment, and the {\ttfamily params} entry contains a {\bfseries J\+S\+ON} object for declaring the parameters. {\ttfamily model\+\_\+dir} contains the location of the outputs and logs for the experiment.

The following configuration, with the corresponding interface definition may be a viable description for an experiment.


\begin{DoxyCode}
1 interface = Interface(**\{
2         'policy':               (0, Policy),
3         'language\_identifiers': (1, None),
4         'languages':            (2, Language),
5         'model':                (3, Model),
6         'initial\_translator':   (4, WordTranslator),
7         'reguralizer':          (5, Classifier)
8 \})
\end{DoxyCode}



\begin{DoxyCode}
1 \{
2     "type": "MergedCurriculumTranslation",
3     "params": \{
4         "policy": "configs/utils/policies/policy.json",
5         "language\_identifiers": [
6             "<ENG>",
7             "<FRA>"
8         ],
9         "languages": [
10             "configs/utils/languages/english.json",
11             "configs/utils/languages/french.json"
12         ],
13         "model": "configs/models/sts.json",
14         "initial\_translator": "configs/utils/translators/word.json",
15         "reguralizer": "configs/components/reguralizers/mlp.json"
16     \},
17     "model\_dir": "model\_outputs/unmt\_3"
18 \}
\end{DoxyCode}


The type of the experiment is {\ttfamily Merged\+Curriculum\+Translation}, that requires a {\ttfamily policy}, which is a complex parameter, that defines specific behaviours for the model during training, validation or testing phase. {\ttfamily language\+\_\+identifiers} is a primitive, that should contain a list of strings, which will identify the languages, that are used in the experiment. {\ttfamily languages} is a complex parameter, that yields its values as a list. A {\ttfamily Language} object defines the input pipelines and the vocabulary for a language. {\ttfamily model} is the configuration for the model, that will be in the experiment. For further examples see the pre-\/defined experiment configurations in the $\ast$/configs/tasks$\ast$ directory.

\subsubsection*{Model configurations}

Model configurations must follow the format, which is described in the following examples.


\begin{DoxyCode}
1 \{
2     "type": "<Model Type>",
3     "params": "<Model Components"
4 
5 \}
\end{DoxyCode}


The following example shows a possible configuration for the model.


\begin{DoxyCode}
1 \{
2     "type": "SeqToSeq",
3     "params": \{
4         "encoder":  \{
5             "type": "UnidirectionalRNNEncoder",
6             "params": \{
7                 "hidden\_size": 100,
8                 "recurrent\_type": "LSTM",
9                 "num\_layers": 3,
10                 "optimizer\_type": "Adam",
11                 "learning\_rate": 0.01
12             \}
13         \},
14         "decoder": \{
15             "type": "RNNDecoder",
16             "params": \{
17                 "hidden\_size": 100,
18                 "recurrent\_type": "LSTM",
19                 "num\_layers": 3,
20                 "optimizer\_type": "Adam",
21                 "learning\_rate": 0.01,
22                 "max\_length": 15
23             \}
24         \}
25     \}
26 \}
\end{DoxyCode}
 The type for the model was defined as sequence to sequence, which requires an encoder and decoder as it\textquotesingle{}s components. $\ast$(To learn more about the required parameters for a given model, see the corresponding R\+E\+A\+D\+M\+E.\+md files in the modules directories.)$\ast$ In case of the {\ttfamily Seq\+To\+Seq} model, {\ttfamily encoder} and {\ttfamily encoder} are required nodes, and there will be an error message indicating their absence. After parsing the defined type of components, the application will look for the parameters required for the instantiation. The parameters shown in the example are $\ast$(currently)$\ast$ sufficient for any of the {\ttfamily encoder} or {\ttfamily encoder} type modules. 